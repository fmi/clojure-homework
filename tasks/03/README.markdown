# Брояч и декоратори

В тази задача ще трябва да реализирате един брояч (чрез три функции и една динамична променлива) и четири декоратора.

За целите на тази задача ще наричаме "декоратор" функция от по-висок ред, която приема функция и връща версия на функцията с някакво допълнително поведение. Например `fnil` е декоратор, който променя аргумента на функцията от `nil` на нещо друго.

    (def safe-inc (fnil inc 0))
    (safe-inc 10)  ; 11
    (safe-inc nil) ; 1

## Брояч

Дефинирайте брояч с помощта на три функции: `(reset-counter!)`, `(count!)` и `(get-count)`. Трябва да работи по следния начин:

    (reset-counter!)

    (count!)
    (count!)
    (get-count) ; 2

    (count!)
    (get-count) ; 3

    (reset-counter!)
    (get-count) ; 0

Текущата стойност на брояча трябва да може да се модифицира чрез динамична променлива `*counter*`, която може да бъде променена на атом от число.

    (binding [*counter* (atom 10)]
      (get-count) ; 10

      (count!)
      (get-count)) ; 11

* Броячът започва от 0
* `count!` го инкрементира атомарно
* `reset-count!` рестартира стойността му на 0
* `get-count` връща текущата стойност
* `*counter*` е динамичен атом, съдържащ текущата стойност

## add-metrics

Имплементирайте декоратор `(add-metrics func fkey)`, която брои колко пъти функцията е била извикана с определени аргументи. За да направите проверката може да ползвате `(calls fkey & args)`, където `fkey` е подадената стойност на `add-metrics`. `fkey` може да бъде от всякакъв тип.

Например, ако искате да добавите метрики към `+`, може да го направите така:

    (def my+ (add-metrics + :add))

Извиквате `my+` няколко пъти:

    (my+ 1 2)
    (my+ 2 3)
    (my+ 1 2)

Вече може да проверите броя извиквания с `calls`, използвайки `:add` (което подадохме на `add-metrics`):

    (calls :add 1 2) ; 2
    (calls :add 2 3) ; 1
    (calls :add 3 4) ; 0

* Обърнете внимание, че ключа подаден на `add-metrics` се ползва, за да се провери резултата чрез `calls`.
* Ако две функции са регистрирани с един и същи ключ, техните метрики се смесват.
* `calls` връща 0, ако функцията не е била извиквана с тези аргументи.

## add-events

Имплементирайте декоратор `add-events`, който да връща нова функция, която може да има before и after събития. Събитията се подават с динамични променливи `*before*` и `*after*`. `add-events` взема ключ, подобно на `add-metrics`

    (def my+ (add-events + :add))

    (binding [*before* {:add (fn [& args] (printf "About to add %s\n" args))}
              *after*  {:add (fn [result & args] (printf "The sum of %s is %s\n" args result))}]
      (my+ 1 2))
    ; About to add (1 2)
    ; The sum of (1 2) is 3

* `(add-events fun fkey)` взема функция и ключ.
* `*before*` и `*after*` са динамични променливи, които може да са недефинирани.
* Когато динамична променлива е дефинирана, всяка е мап, в който ключовете са `fkey`-ове (подадени на `add-events`), а стойностите са функции, които да се изпълнят преди или след извикването.
* Функциите в `*before*` трябва да приемат неограничен брой аргументи, като на тях се подават аргументите, с които декорираната функция ще бъде извикана.
* Функциите в `*after*` приемат неограничен брой аргументи, като първия е резултата от извикването на декорираната функция, а останалите - аргументите, с които тя е извикана. В горния пример, при `(my+ 1 2)`, after събитието се извиква с `(3 1 2)`.
* Функции в `*before*` и `*after*` се викат само когато техния ключ съвпада с fkey-а, подаден на `add-events`.

## cache

Имплементирайте декоратор `(cache func)`, която мемоизира подадената функция. `cache` трябва да слага стойност на динамична променлива `*cache-hit*`, съответно: `true` ако използваме предварително изчислен резултат или `false`, ако функцията за първи път се извиква със съответните аргументи. Например:

    (def my+ (cache +))

    (binding [*cache-hit* nil]
      (my+ 1 2)
      *cache-hit*  ; false

      (my+ 1 2)
      *cache-hit*  ; true

      (my+ 2 3)
      *cache-hit*) ; false

* Декорираната функция трябва да се изпълнява само веднъж за всяка уникална конфигурация от аргументи.
* `*cache-hit*` може да няма зададена с `binding` стойност.

## annotated

Финално, имплементирайте декоратор `(annotated fvar)`, който взема променлива и връща функция, декорирана спрямо нейните метаданни:

* Ако има ключ `:cached` със стойност истина, функцията се декорира с `cache`
* Ако има ключ `:events`, функцията се декорира с `add-events` и fkey - стойността на `:events` в метаданните
* Ако има ключ `:metrics`, функцията се декорира с `add-metrics` и fkey - стойността на `:metrics` в метаданните

Например:

    (defn add
      {:cached true
       :events :+
       :metrics "addition"}
      [& args]
      (count!)
      (apply + args))

    (def my-add (annotated #'add))

* Метриките и събитията трябва да работят за кеширани функции. Т.е., ако кеширана функция се извика повторно с едни и същи аргументи, метриките трябва да се обновят и събитията - изпълнят.
* Обърнете внимание, че `annotated` взема променлива, а не функция.
* Очевидно не е нужно всички ключове (или дори някакви) да са в метаданните.
* Погледнете `cond->` в Clojure 1.5
