# Игра с точки

Във втората задача трябва да напишете функция `game`. Тя трябва да приема като аргументи два мапа, които ще наричаме играчи и връща поредица от два елемента, която съдържа броя на точките събрали първия и втория играчи при играта, която е описана по-долу в условието.

## Предварително известни факти

* всички ключове на играчите са ключови думи
* играчите могат да имат само мапове, вектори, функции, множества или мързеливи поредици
* всички мапове, които играчите имат са или празни или само от цели числа. Ключовете им са винаги ключови думи. Примери: `{}` `{:baba 5}` `{:a 42 :b -69 :x 4360000634}`
* всички вектори, които играчите имат са или празни или са вектори от списъци от цели числа. Списъците също могат да бъдат празни. Примери: `[]` `[()]` `['(1023 4095 8191) () () '(0 17) '(3)]`
* всички функции, които играчите имат приемат два аргумента цели числа и връщат цяло число
* всички множества, които играчите имат са от цели числа
* всички мързеливи поредици, които играчите имат са от цели числа
* може да разчитате, че тези условия ще бъдат изпълнени и няма нужда да ги проверявате

## Правила:

### Последни три, първи три

Всеки играч получава **1 точка** за всеки вектор, който започва с последните три списъка на друг вектор на същия играч. Ето пример за играч, който ще получи точка по този параграф:

    (def player {:v0 [() '(11) '(6 -1 3) '(5)] :v1 ['(11) '(6 -1 3) '(5) '(23 3 3 3 -1) () () '(5)]})

### Средно-аритметично

Всеки играч получава по **1 точка** за всеки вектор, за който средното-аритметичното от сумите на квадратите на елементите на всеки списък в него е по-голямо от средно-аритметичното на всички цели числа в другия играч. Ако списък е празен неговата сума е 0. Ако един вектор е празен, неговото средно артиметично също е 0. Ако един играч няма числа, средното им аритметично отново е 0.

В този пример векторът на играч 1 има средно-аритметично от 25 ((5 + 0 + 68 + 27)/4) и получава точка, защото средното аритметично на всички числа на играч 2 е малко под 24:

    (def player1 {:v ['(1 2) () '(8 -2) '(-1 5 -1)]})
    (def player2 {:v ['(7 150) '(4 33)] :m {:f -50} :f (comp + + -) :s #{-1}})

**Важно:** в числата на един играч се вклюват само числата от векторите, речниците и множествата. Мързеливите поредици не се включват, защото може да бъдат безкрайни и ще ви бъде трудно да им сметнете сумата.

### Комутативно фибоначи

Всеки играч получава по **1 точка** за всяка функция в него, която удовлетворява следните изисквания:

* извикана с аргументи 0 и 0 връща 0
* комутативна e за всички двойки числа, от 0 до 99 включително
* викната с две валидни числа на фибоначи, между 1 и 99 включително, връща 111

### Уф

Всеки играч полуава по **3 точки** за всеки мап, който:

* за всеки негов ключ, съответстващото му число е по-голямото от сумата на всички числа съответстващи на същия ключ в мапове на същия играч (без да броим този мап, разбира се) или няма други мапове със същия ключ
* ако бъде сортиран по един специален начин, то, обърнатите до низове, ключове на първите 6 стойности са "List", "Vector", "Map", "Set", "LazySeq", и "Cons", без значение от реда или от малки и главни букви

Ето и правилата за сортиране:

* сортираме мапа по броя на цифрите на всяко число, във възходящ ред
* ако две числа имат равен брой цифри, печели числото, за което същия играч има повече функции, които викнати с два аргумента това число връщат същото число

Пример:

    (def player {:m0 {:vector 1 :map 2 :set 15 :cons 234 :list 7513 :LAZYSEQ 88888 :uumf 99999 }
                 :m1 {:cons 231}
                 :m2 {:cons 2}
                 :f (fn [x y] (if (= x 88888) x 5))})

### Двойка мързеливци

Всеки играч получава по **5 точки** за всяка двойка мързеливи поредици, за която съществува множество, което съдържа всички елементи на сумите и произведенията на двойките от декартовото произведение на двете поредици. Пример за играч, който ще получи петте точки:

    (def player {:l0 (lazy-seq (cons 1 (lazy-seq [2]))) :l1 (lazy-seq (cons 1 (lazy-seq [6]))) :s0 (set (range 15))})

Двойките са: [1, 1], [1, 2], [1, 6], [2, 6]. Сумите им са: 2, 3, 7, 8. Произведенията им са: 1, 2, 6, 12. Множеството `(:s0 player)` съдържа всички тези числа.

**Важно:** Мързеливите поредици, както може да видите и от примерния тест, могат да бъдат безкрайни. Ясно е, че няма да може да пресметнете цялото декартово произведение, ако една от поредиците е безкрайна. Ще трябва да бъдете хитри или на практика ще разберете колко време и памет отнема един безкраен цикъл.

## Документация

Няколко полезни функции:

* [instance?](http://clojuredocs.org/clojure_core/clojure.core/instance_q)
* [list?](http://clojuredocs.org/clojure_core/clojure.core/list_q) и други подобни от вида _тип?_
* [flatten](http://clojuredocs.org/clojure_core/clojure.core/flatten)
* [clojure.set](http://clojure.github.com/clojure/clojure.set-api.html#clojure.set) – трябва да ползвате функциите с пълното им име: `clojure.set/union`
* Забележете разликата между [fn?](http://clojuredocs.org/clojure_core/clojure.core/fn_q) и [ifn?](http://clojuredocs.org/clojure_core/clojure.core/ifn_q)

Припомняме ви, че може да разгледате [Clojure cheatsheet](http://clojure.org/cheatsheet) ако се почувстате загубени или документацията в [Clojure Docs](http://clojuredocs.org/quickref/Clojure%20Core), която макар и за Clojure 1.3 е релевантна.

Успех :-)

